#version 460 core
layout (triangles, equal_spacing, ccw) in;

uniform mat4 view_projection;

in vec3 world_pos_TES_in[];
in vec3 world_normal_TES_in[];
in vec2 texcoord_TES_in[];

out vec3 world_pos_GS_in;
out vec3 world_normal_GS_in;
out vec2 texcoord_GS_in;

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
    return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

// Gold Noise ©2015 dcerisano@standard3d.com
// - based on the Golden Ratio
// - uniform normalized distribution
// - fastest static noise generator function (also runs at low precision)
// - use with indicated seeding method. 
float PHI = 1.61803398874989484820459;  // phi = Golden Ratio   

float gold_noise(in vec2 xy, in float seed)
{
   return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);
}

void main()
{
	// Interpolate the attributes of the output vertex using the barycentric coordinates
    texcoord_GS_in     = interpolate2D(texcoord_TES_in[0], texcoord_TES_in[1], texcoord_TES_in[2]);
    world_normal_GS_in = interpolate3D(world_normal_TES_in[0], world_normal_TES_in[1], world_normal_TES_in[2]);
    world_normal_GS_in = normalize(world_normal_GS_in);
    world_pos_GS_in    = interpolate3D(world_pos_TES_in[0], world_pos_TES_in[1], world_pos_TES_in[2]);

    // Displace the vertex along the normal
    world_pos_GS_in += world_normal_GS_in * gold_noise(texcoord_GS_in, 123) * 0.5;
    gl_Position = view_projection * vec4(world_pos_GS_in, 1.0);
}